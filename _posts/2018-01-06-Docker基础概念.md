# Docker 基础概念

- [Docker 基础概念](#docker-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5)
    - [镜像 —— `Image`](#%E9%95%9C%E5%83%8F--image)
        - [简述](#%E7%AE%80%E8%BF%B0)
        - [特点：分层存储](#%E7%89%B9%E7%82%B9%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8)
    - [容器 —— `Container`](#%E5%AE%B9%E5%99%A8--container)
        - [简述](#%E7%AE%80%E8%BF%B0)
        - [容器和虚拟机](#%E5%AE%B9%E5%99%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA)
        - [容器存储层](#%E5%AE%B9%E5%99%A8%E5%AD%98%E5%82%A8%E5%B1%82)
    - [仓库 —— `Repository`](#%E4%BB%93%E5%BA%93--repository)
        - [简介](#%E7%AE%80%E4%BB%8B)
        - [公开 Docker Registry](#%E5%85%AC%E5%BC%80-docker-registry)
            - [国内镜像加速器](#%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8)
        - [私有 Docker Registry](#%E7%A7%81%E6%9C%89-docker-registry)


## 镜像 —— `Image`
### 简述
对于 Linux 而言，内核启动之后，会挂载 root 文件系统来提供空间支持。Docker 镜像就属于特殊的文件系统，相当于一个 root 文件系统。

Docker 在设计时，使用 `Union FS` 的技术，将其设计为分层存储的架构。

所以 Docker 中的镜像与传统意义上的镜像并非完全一样，Dcoker 的镜像在这里是一个虚拟的概念，具体来说，它由一组或多组文件系统联合组成
### 特点：分层存储
Docker 在进行镜像构建时，会 **逐层进行构建** ，前一层是后一层的基础，每一层构建完成后不会发生改变，后一层上发生的任何改变不会影响其他层。

比如在后一层上进行文件删除操作，**仅是在当前层把被删除文件标记为已删除** ，在容器运行的时候不会显示已删除的文件。但在前一层上，文件依旧在，而且会一直跟随镜像存在

分层存储的特征简化了镜像的 **复用** 和 **定制**。甚至可以选择之前构建好的镜像作为基础层，然后添加需要的内容做为新的层。
## 容器 —— `Container`
### 简述
容器的实质是进程，与直接在宿主执行的进程不同，容器进程运行于自己的命名空间。

因此容器拥有良好的隔离性，容器也有自己的文件系统、网络配置、进程空间、甚至是用户的 ID 空间。

因为容器的沙箱特性，使用容器封装的应用要比直接运行在宿主机上有更高的安全性

### 容器和虚拟机
容器和虚拟机同属虚拟化技术，内里的技术却存在截然不同的实现：
1. 资源方面

    - 传统的虚拟机需要模拟整台计算机硬件，需要有自己的操作系统、系统库和应用。一旦开启，分配的资源将会被**全部占用**。

    - 容器则是与宿主机共享硬件资源、操作系统，资源**动态分配**，容器包含所有依赖包和自己的应用。多个容器将共享内核，在宿主机中以分离的进程运行

2. 虚拟化层面
    - 传统的虚拟机实现了**对硬件资源的虚拟**，容器技术则是**对进程的虚拟**
3. 架构方面
    - 传统虚拟机使用 `Hypervisor` 技术来进行虚拟化，`Hypervisor` 管理虚拟机的操作系统运行 
    - Docker 使用 `Docker Engine` 完成资源的调度和进程的隔离，通过内核共享省去传统虚拟机的 OS 层，
4. 使用情况层面
    - 传统虚拟机能提供**更安全的隔离环境**，能够完成一致的生产环境交付，
    - Docker 更轻量级，通过 `Dockerfile` 记录容器的构建过程，来完成**集群内的快速分发和快速部署**
### 容器存储层
`镜像` 和 `容器` 的关系，可以类比为面向对象编程中 `类` 和 `实例对象` 的关系

每个 `Docker` 镜像引用一个或多个代表文件系统差异的**只读数据层**。数据层以堆栈形式来组成容器的根文件系统。

每一个容器在创建的时候，都会在堆栈底层创建一个可写的数据层，这就是容器数据层（ `container layer` ）

所有对容器的更改——读写文件、更新/删除文件，都会写到这个数据层

容器数据层的生命周期跟容器一样——**容器数据层 随 容器 的 删除 而 丢失**

按照 《Docker 最佳实践》的要求，容器的数据层要保持无状态化，即不应该向其内写入任何数据。

任何文件写入操作都应该使用**数据卷**、**绑定宿主目录** 等操作，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，稳定性和性能更高
## 仓库 —— `Repository`
### 简介
仓库 ( `Respository` ) 是 `Docker Registry` 服务中的一个术语。`Docker Registry` 服务用于集中存储、分发镜像 。

> 一个 `Docker Registry` 服务中可以包含多个仓库 ( `Respository` )；
> 
> 一个仓库 ( `Respository` )中可以包含多个标签 ( `Tag` ) ；
> 
> 一个标签 ( `Tag` ) 对应一个镜像。

通常一个仓库会包含同一个软件不同版本的镜像，而标签则对应软件的版本,通过 `<仓库名>:<标签>` 的形式来指定需要的镜像，如果不给出标签，则将以 `latest` 作为默认标签
### 公开 Docker Registry
`Docker Registry` 公开服务是开放给用户使用、允许用户管理镜像的 `Registry` 服务

#### 国内镜像加速器
最常使用的公开服务是官方的 `Docker Hub`，这也是默认的 `Registry`，因为网络原因国内的云服务商提供了针对 `Docker Hub` 的镜像服务 （ `Registry Mirror` ） ，这些镜像服务被称为**加速器**
### 私有 Docker Registry
可以在本地搭建私有的 `Docker Registry` 。Docker 官方提供了 `Docker Registry` 镜像，可以直接使用做为私有 Registry 服务