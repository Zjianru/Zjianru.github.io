---
layout:     post
title:      事务管理与并发控制
subtitle:   事务基础
date:       2019-03-11
author:     Alessio
header-img: img/PostBack_03.jpg
catalog: true
tags:
    - SQL 事务
---

## **为什么要有事务处理机制？**

| **1** | 解决脏读/不可重复读/幻读？×                 |
|-------|---------------------------------------------|
| **2** | 实现了ACID特性？×                           |
| **3** | 多版本两阶段封锁协议实现可串行化快照隔离？× |

 

要保证用户的数据操作动作是 **安全** 的

只有在带有 **ACID** 特性的事务处理机制的保障下，才可以认为是安全的

| **Atomicity**   | 原子性 |
|-----------------|--------|
| **Consistency** | 一致性 |
| **Isolation**   | 隔离性 |
| **Durability**  | 持久性 |

事务概念及其相关技术 抽象出 一个数据处理模型，可以保证：

>   **操作间串行执行，执行中不必担心出错**

| A    | 有完整逻辑意义的数据读写操作要么成功，要么失败 | 
|------|--------------------------------------------|
| A&C  | 数据不会因操作发生不一致                     |
| I    | 多会话并发读写同一份数据的情况下数据的完整一致 |
| D    | 被修改的数据能够长久保存                     |

 

## **事务机制要处理的问题：**

事务故障：

预期的故障—可以通过数据库的事务处理机制发现的事务内部故障

非预期的故障—运算溢出故障 / 并发事务死锁故障 / 违反完整性约束导致的故障

| 预期的故障   | 回滚 |
|--------------|------|
| 非预期的故障 | 回滚 |

系统故障：

由于不可抗力 数据库系统停止运行

| 正在运行的事务以非正常方式终止 | 基于 REDO/UNDO 的恢复机制 |
|--------------------------------|---------------------------|


介质故障（硬故障）：

不可抗力导致

数据丢失 | 备份系统 / 归档日志 
|-----|-----|

## **数据异常图解**

读-读操作：如果同时存在多个读操作，对于数据本身没有影响，（不会影响数据一致性）

>   读-读操作可以并发执行

读-写操作：如果读写操作都存在，可能会出现下列情况：

| 脏读       | 写在前 读在后                                   |
|------------|-------------------------------------------------|
| 不可重复读 | 读在前写在后                                    |
| 幻读       | 读在前写在后然后又读 最后的读操作读到错误的数据 |

写-写操作：多个写操作直接改变了数据在同一时刻的语义——写-写操作一般不允许并发

>   如果不做并发控制，写-写操作会带来数据异常

### 读异常

| | | | | | | |
|------|------------------------------------------------|------------|---------------------|------------|--------------------|------------|
|      | 脏读                                           |            | 不可重复读          |            | 幻读               |            |
|      | dirty Read                                     |            | Non-repeatable Read |            | Phantom            |            |
| 时间 | T1主事务                                       | T2         | T1主事务            | T2         | T1主事务           | T2         |
| T0   |                                                | row-update | Read-row            |            | Read-row \<where\> |            |
| T1   | read-row                                       |            |                     | update-row |                    | row-update |
| T2   |                                                | Abort      |                     | commit     | Read-row \<where\> |            |
| T3   |                                                |            | Read-row            |            |                    |            |


### 脏读异常的变形

| 脏读   | Dirty Read        |
|--------|-------------------|
| 撤销读 | Aborted Read      |
| 中间读 | Intermediate Read |

#### 脏读异常变形图解：

| ||              |                         |              |                              |              |
|----------|---------------------|--------------|-------------------------|--------------|------------------------------|--------------|
|          | **脏读 Dirty read** |              | **撤销读 Aborted Read** |              | **中间读 Intermediate Read** |              |
| **时间** | **T1**              | **T2**       | **T1**                  | **T2**       | **T1**                       | **T2**       |
| **T0**   | **row-update**      |              | **row-update**          |              | **row-update**               |              |
| **T1**   |                     | **row-Read** |                         | **row-Read** |                              | **row-Read** |
| **T2**   | **Abort**           |              |                         | **Commit**   |                              | **Commit**   |
| **T3**   |                     |              | **Abort**               |              | **row-update**               |              |



-   脏读：事务 T2 读到了一个将要被撤销的事务 T1 写的数据

-   撤销读：已经提交的事务 T2 读到了一个将要被撤销的事务 T1 写的数据

-   中间读：已经提交的事务 T2 读了事务 T1 临时写的一个中间状态的数据


### 写异常

|          | **脏写**        |                | **丢失更新**     |                |
|----------|-----------------|----------------|------------------|----------------|
|          | **Dirty Write** |                | **Lost Update**  |                |
| **时间** | **T1**          | **T2**         | **T1**           | **T2**         |
| **T0**   | **row-update**  |                | **row-Read**     |                |
| **T1**   |                 | **row-update** |                  | **row-update** |
| **T2**   |                 | **commit**     | **row-update**   |                |
| **T3**   | **Abort**       |                | **commit**       |                |




## **数据异常现象：**

1.  涉及并发事务

2.  涉及隔离级别

>   如果多个事务是可串行化的，则意味着事务之间不应该相互影响，采取分级控制（不同的隔离级别）来避免

| 脏读       | 已提交读 `READ COMMITTED` |
|------------|-------------------------|
| 不可重复读 | 可重复读 `REPETABLE READ` |
| 幻读       | 可串行化 `SERIALIZABLE`   |

1.  数据操作的对象。脏读和不可重复读是以行（row）为单位，幻读操作的是一个数据集

## **事务的属性详解**

-   **可串行化—— `Serializability`**

>   可串行化是一个调度 即多个事务之间的执行方式

-   可串行化调度（`Serial schedule`）

    -   事务之间没有共同的操作对象

    -   对于存在共同操作对象的多个并发执行的事务，如果其结果“等价”某个串行化调度，则这个调度是可串行化的

    -   为了保证调度结果 等价 串行化概念 引入下面的概念

        -   冲突行为 `conflicting actions`

>   又称 冲突动作 当两个动作满足如下三个条件，则这两个动作是冲突的：

-   两个动作属于不同的事务

-   至少一个动作是写操作

-   动作在操作同一个对象

-   冲突等价 `conflict equivalence`

>   对于不同的事务的调度方式 S1 和 S2 若满足以下条件 S1 和 S2 等价：

-   S1 和 S2 调度方式包含同样的事务集合

    -   每个事务中的操作的顺序都是固定的 不能在不同的调度方式下发生变化

-   S1 和 S2 调度方式包含同样的冲突操作集合

-   冲突可串行化 `conflicet-serializable`

    -   当某个调度 “冲突等价”与一个或多个 “串行调度” 则这个调度是
        "冲突可串行化"的

    -   相当于把并发事务等价于某“多个事务的串行执行”

-   可串行化概念的作用在于**保证并发的事务调度方式既能满足数据一致性要求，又能提高并发事务的执行效率**

-   **如何保证可串行化？**

| **基于锁的方法**         | **阻塞其他产生冲突的事务**         |
|--------------------------|------------------------------------|
| **基于时间戳的方法**     | **回滚产生冲突的事务**             |
| **基于有效性检查的方法** | **基于时间戳的并发控制方法——回滚** |

>    

-   **可恢复性 —— `Recoverability`**

    -   是并发的事务后期，表明提交事务间相互影响的属性

    -   即 **已经提交的事务没有读过被终止的事务的写的数据**

    -   保证的是 **多个事务并发调度后期的提交顺序对数据的一致性没有影响**

-   **严格性 —— `Strictness`**

    -   严格性概念的作用在于保证：

        -   有冲突动作——前面所述的“冲突行为”的并发的事务中，先发生写操作的事务提交或中止的操作优先于其他事务

## **数据异常现象的出现：**

**读-读操作**

-   脏读

>   按照时间顺序

>   T1 事务在 T0 时刻对 row 进行了更新

>   T2 事务在 T1 时刻先读取了被 T1修改后的 row 值

>   T1 事务在 T2 时刻被终止，使得修改没有完成

>   如果数据库不支持因为并发操作避免数据异常

>   那么 T2 在 T1 时刻读到的就是被 T1 修改后的数据

>   即 **事务 T2 读到了被回滚的数据**

>   **事务 T2 发生脏读**

-   不可重复读

>   按照时间顺序

>   T1 事务在 T0 时刻先读到 row 值

>   T2 事务在 T1 时刻对 row 进行了修改（更新或删除）

>   T2 提交事务 row 完成修改（被更新 / 被删除）

>   T1 事务在 T3 时刻再次读取 row

>   **物是（读取的仍然是 row）**

>   **人非（数据变了）**

>   **T1 事务发生不可重复读**

-   幻读

>   按照时间顺序

>   T1 事务在 T0 时刻带有特定条件地读取 row 的数据

>   T2 事务在 T1 时刻插入新数据 / 更改旧数据

>   更新满足T1 事务的特定条件

>   T1 事务在 T3 时刻以同样的条件再次读取 row

>   **物是（ row 还是那个 row，条件还是那个条件 ）**

>   **人非（ 值变了 ）**

>   **T1 事务发生幻读**

**写-写操作**

-   脏写

>   按照时间顺序

>   T1 事务在 T0 时刻对 row 进行了更改

>   T2 事务在 T1 时刻对 row 进行了更改

>   如果没有并发控制 T2 对值的改变会写入

>   T1 事务在 T3 时刻回滚使得 T2 对 row 的修改失效

>   **T1 事务的语义**是

1.  自身对 row 的修改失效

2.  把 T2 事务修改的值进行回滚

>   即 **T1 事务回滚掉了不是自己修改的数据**

>   **T1 事务发生了脏写**

-   丢失更新

>   按照时间顺序

>   T2 事务在 T1 时刻对 row 进行了修改

>   T1 事务在 T2 时刻对 row 进行了修改

>   如果没有并发控制

>   T1 事务对 row 的修改生成新值

>   T1 事务在 T3 时刻提交使得 T2 事务对 row 的修改失效

>   即 **事务 T1 覆盖掉了不是自己修改的数据**

>   **事务 T1 上引发了丢失更新**

## **事务的模型**

事务的实现 在不同的数据库系统中并不相同 这是因为事务有不同的模型
在《事务处理概念与技术》中 作者把事务分成如下几种：

-   **平板事务 `Flat Transactions`**

事务块中所有 SQL 语句，构成一个逻辑单元，要么都成功，要么因之一失败而全部回滚

-   PostgreSQL 的事务管理如果不考虑保存点（
    Savepoint）机制，可以认为是一个平板类型的事务

    -   事务块内的一个 SQL 失败，整个事务必须回滚，包括之前成功的操作

-   **带保存点的平板事务 `Flat Transactions with Savepoints`**

在平板事务的基础上，实现了保存点技术，使得一个事务块可以划分出不同的层次，每个层次之间为一个逻辑单元，后面失败的
SQL 不影响保存点之前发生的操作——回滚发生在局部

-   PostgreSQL / InnoDB / Informix 在平板事务的基础上支持了保存点技术

-   **链式事务 `Chained Transactions`**

链式事务在提交一个事务之后，会释放一些资源（比如锁）

-   其上下文环境（比如事务的载体——存放事务的结构体或类等对象）不会释放，会留给下一个事务使用

-   在使用的时候 感觉逻辑单元不会被 Commit 之类的命令进行明显的分割

-   **嵌套事务 `Nested Transactions`**

嵌套事务如同一颗树，树有子叉，每一个子叉可以是嵌套的子事务 也可以是平板的子事务
但**叶子节点的事务是平板事务**

根节点的事务提交，整个事务的数据修改才会生效，否则只是事务内局部生效

-   **分布式事务 `Distributed Transaction`**

在分布式环境下的平板事务或以上其他类型的事务

-   **多层次事务 `Mult-Level Transactions`**

多层事务也如同一颗树，根是事务的总结点，下层是对象操作（Object
Operation）作为子事务存在

对象操作还可以带有子对象事务操作节点，或带有一个/多个叶子节点（`Page poperation`）

这样的实物模型可以有自己独特的并发控制处理技术

-   现实有的工程实现并不多，其事务分类与之前的事务分类角度也不同

**概念明确**

-   **提交 commit**

    -   事务的动作 表示事务成功执行

-   **终止 abort**

    -   事务的动作 表示撤销事务的执行

    -   会引发回滚动作的执行

-   **回滚 rollback**

    -   事务的动作 表示撤销事务的执行 会有进一步的动作 分两种情况

>   多数情况下 回滚的含义是第一种

-   意在恢复被修改的数据 —— 恢复旧的数据使数据一致性得到保证

    -   只读事务的中断不会触发恢复

    -   更新事务 写操作发生中止后需要回滚

-   被终止的事务在被中止后 此事务被事务调度器自动重启

    -   事务被重新赋予新的时间戳 开始执行

    -   这种技术用于基于时间戳的排序并发控制技术当中

 

**即使数据库系统提供 ACID， 除非使用“可串行化（SERIALIZABLE）”隔离级别**

**否则数据在其他隔离级别下还会产生数据不一致的情况**

 

## **事务处理技术的原理**

 
什么是事务？

事务是数据库关系系统中一系列操作的一个逻辑单元

**事务的特性——ACID详解**

-   **`Atomicity` 原子性：**

强调两种结果 —— all / nothing

对应两种状态 —— commit / abort

-   **`Consistency` 一致性：**

事务的操作使”特定的数据“状态发生变迁，但前后的结果对应的状态一直是 ”valid“ 的

什么才是 valid 操作？

>   数据在事务的操作下，一直符合“all defined rules” ——这些规则是数据的逻辑语义

-   约束？

>   约束属于用户的语义所限定的数据的一致性

一致性的另一层含义，属于系统级，指：

要想数据在数据库系统中保持一致，要求数据库系统符合两个特性：

-   可串行性 ( serializability )

    -   保证数据不被并发改坏

-   可恢复性 ( recoverability )

    -   可恢复性：已经提交的事务未曾读过被回滚的事务写过的数据 —— 不会发生“脏读”

    -   保证事务回滚之后数据回到之前的“valid”状态

-   **`Isolation` 隔离性**

    -   强调 “concurrent execution”

>   存在多个事务同时进行，但他们运行的顺序好像是 “serially”的

>   即 并发“看起来” 像是 串行

>   “并发”的这些动作对数据的操作之后 数据应该是 “vaild”的

-   可串行化隔离性的定义是“serializability”

>   区分隔离性 与 “隔离级别”与 “隔离级别”中的可串行化“SERIALIZABLE”

-   **`Durability` 持久性**

强调 对于“committed”状态的数据，要能够永久保存，有如下两点：

-   物理存储

-   防止处于“commit”状态的数据
    因为数据库引擎没来得及把数据存储到物理存储上（掉电）而丢失已被“commit”的数据

-   原子性中提到的“Abort”状态的数据，持久性是不关注的

 

## **ACID的实现技术**

我们提出一个问题：

**请总结一下 哪些技术是分别实现 A C I D 的？**

我们得到了这样的一个思维导图：

![原子性](https://raw.githubusercontent.com/Zjianru/zjianru.github.io/master/img/%E5%8E%9F%E5%AD%90%E6%80%A7.png)
![一致性](https://raw.githubusercontent.com/Zjianru/zjianru.github.io/master/img/%E4%B8%80%E8%87%B4%E6%80%A7.png)
![隔离性](https://raw.githubusercontent.com/Zjianru/zjianru.github.io/master/img/%E9%9A%94%E7%A6%BB%E6%80%A7.png)
![持久性](https://raw.githubusercontent.com/Zjianru/zjianru.github.io/master/img/%E6%8C%81%E4%B9%85%E6%80%A7.png)

 
## **日志技术与恢复子系统**

日志技术是有效实现原子性和持久性的重要技术之一

需要记录的数据包括：

-   事务的标识

-   数据项的标识

-   旧值

-   新值

日志 —— 一系列的操作构成了一个操作序列并带有过程中产生的数据

日志产生后存放在日志缓冲区 然后被刷出到外存 存放在日志文件里

日志根据所记载的内容 分成两种

-   REDO 日志

    -   记录事务标识

    -   记录数据项标识

    -   记录新值

-   UNDO 日志

    -   记录事务标识

    -   记录数据项标识

    -   记录旧值

在系统运行期间发生事务故障 数据库执行回滚操作 使用UNDO
日志中的旧值来完成数据覆盖

在系统故障发生 需要系统恢复时 使用 UNDO 日志和 REDO 日志 有这两种策略来完成恢复

-   恢复时 只使用 REDO 日志重做已提交的事务 省却UNDO 日志

-   恢复时 使用REDO 日志重做所有事务 包括 回滚 和 未提交 的事务 在使用 UNDO
    日志回滚未提交的事务
