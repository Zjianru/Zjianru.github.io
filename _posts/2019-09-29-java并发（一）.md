---
layout:     post
title:      Java 并发详解-从线程开始
subtitle:   java Concurrent (一)
date:       2019-09-29
author:     Alessio
header-img: img/PostBack_01.jpg
catalog: true
tags:
    - java
    - 多线程和并发
---
## 从操作系统开始

java 的并发一直是面试中的痛点，涵盖的知识点也极其多，小到关键字，大到 JMM。都是可能涉及的问题点，但是我并不想去为了面试去做应试化的准备，而是想从头来介绍这些内容，从下而上，仔细深入的去做知识的介绍。

那么第一件事，就要从线程的起源开始了
- 从操作系统开始
    - CPU核心数和线程数

    实际上来讲，线程数和CPU核心数应该是相等的 —— 一个 CPU 负责一个线程的任务，但是带来的问题是，在一个线程因为 CPU 和其他硬件设施的运转速度不一致而陷入“合理的等待”情况，CPU的占用率反而并没有如我们期望的达到满载。

	自从英特尔的超线程技术出现以后，线程数可以超越CPU核心数，达到 1：2 的比例
	- CPU时间片轮转机制
	CPU的时间片轮转机制实际也称 RR 调度 `Round-robin scheduling`，在RR调度的策略下，一个线程会一直运行，直到以下三种情况发生一种：
		- 自愿放弃控制权
		- 控制权呗更高优先级的线程抢占
		- CPU 时间片用完
	一个CPU时间片，通常是一个时钟周期的4倍

基于RR调度，CPU可以在多个线程之间进行任务切换，在付出**上下文切换**的开销之后，使体验达到**伪并行**的效果

## 解释几个概念
- 线程和进程，线程和纤程
    - 进程实际才是一个应用程序的“本体”，线程则是更轻量级的，用来协助主进程完成任务的“小弟”，进而在开发中，我们更多的是面向线程的调度和管理，是多线程，而非多进程
    - 线程是CPU调度和分派的基本单位，线程间通信靠的是共享内存，上下文切换相对较快，除了必要的资源（程序计数器，一组寄存器和栈），并不会占用其他资源，而是与其他协作线程共享进程的资源
    - 纤程实际是一个很早的概念，但在最近才在某些语言里应用起来，比如 go 语言和 Lua 。
    也称“协程”，是一种“用户态的轻量级线程”。协程的调度由程序控制，在进行协程间切换的时候，更像是操作系统级别的“中断/唤醒”机制，协程保存自己的“事发现场”到别的地方，再次进入的时候则先恢复之前保存的“事发现场”。
        -  协程虽然看上去跟线程类似，但是线程的调用更像是一个栈，先进后出，一层一层地完成程序调用。协程则是类似于中断/唤醒机制，比如我们有一个方法 A 和一个方法 B ，交由线程执行的时候，如果两个方法见没有调用关系，则不会发成调用。但是交由协程来执行，会发生程序“交替执行”的错觉，但是两个方法并没有产生调用。
        - 记住一个点，进程和线程都是同步的，而纤程则是异步的，所以纤程的理解相对要难一点
        - 纤程和线程相比的好处：
            □ 纤程拥有非常高的执行效率，因为纤程切换不是线程切换，需要付出上下文切换的代价。在没有线程切换的开销之后，越多的协程则代表了越高的执行效率
            □ 纤程无锁。锁的开销和管理在多线程开发是极其重要i的一环，但是因为纤程是比县城更轻量级的单位，一个线程可以拥有多个纤程，所以在一个线程的环境下，自然不会出现写变量冲突，纤程控制共享资源的时候只需要判断状态即可，不需要额外的加锁解锁开销
        - 多核CPU如何使用纤程？
            我们刚才只说到，一个线程下可以拥有多个纤程，但是一个进程也可以拥有多个纤程，进而使用“多进程+纤程”，就完美解决问题
