---
layout:     post
title:      浅析 java 中的代理模式（三）
subtitle:   Java Dynamic Proxy - CGLib
date:       2018-11-14
author:     Alessio
header-img: img/PostBack_01.jpg
catalog: true
tags:
    - java
---
## 介绍

之前我们说到，JDK Proxy 是基于接口的，那如果我们想要增强的类就是一个普通的类，没有实现任何接口，那有什么办法能够使用动态代理的方式，为他添加增强呢？

由此，我们便有了这个终极的大杀器 —— `CGLib` 

在 [CGLib 官方wiki](https://github.com/cglib/cglib/wiki) 中，这样描述 CGLib ：

> cglib is a powerful, high performance and quality Code Generation Library,
>  
> cglib 是一个强大、高性能、高质量的代码生成库
> 
> It is used to extend JAVA classes and implements interfaces at runtime
> 
> 它可以在运行期扩展和增强 java 类、实现接口


其实来讲，CGLib 增强类的思路也很简单。

我们都知道方法的重写，可以让方法的 “ 外壳 ” 不发生变化，但是方法的实际执行逻辑都按照我们的新的需求去进行制定

所以 CGLib 使用了**继承**的概念，子类可以重写（扩展）父类某方法的功能，这样就抛开了 JDK 官方那个给我们挖的坑 —— 想要使用动态代理，必须要一个接口

但是正是用 继承 的概念来完成类的增强，所以要被增强的类，**不能是被 final 修饰的**

## 无接口情况下的动态代理实现

现在我们就讨论下没有接口的情况下，如何使用 CGLib 完成动态代理，进行简单的原理剖析

依然使用上篇文章中的例子，我们有一个类 `ServiceForCglib` ，定义了 `doFirst()` 方法和 `doSecond()` 方法，现在我们要求进行功能增强，使 `doFirst()` 方法的返回值是大写类型

```java
public class ServiceForCglib {

    public String doFirst() {
        System.out.println("执行 doFirst");
        return "doFirst in return";
    }

    public void doSecond() {
        System.out.println("执行 doSecond");
    }
}
```