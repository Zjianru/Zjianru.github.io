---
layout:     post
title:      事务管理与并发控制
subtitle:   隔离性与隔离级别
date:       2019-03-22
author:     Alessio
header-img: img/PostBack_03.jpg
catalog: true
tags:
    - SQL 事务
---
 

**隔离级别**

SQL 标准（ANSI）提出四种隔离级别 分别是在三种读数据异常现象前后插入四个点
形成四种隔离地带 不同程度的禁止了三种读数据异常现象的产生

如下图 展示了隔离级别和三个读异常现象

| 三个读异常现象 |                                                        | Dirty read |                                                      | Non-repeatable read |                                    | Phantom |                                                      |
|----------------|--------------------------------------------------------|------------|------------------------------------------------------|---------------------|------------------------------------|---------|------------------------------------------------------|
|                |                                                        | P1         |                                                      | P2                  |                                    | P3      |                                                      |
| 四个隔离级别   | Read Uncommitted                                       |            | Read Committed                                       |                     | Repeatable Read                    |         | Serializable                                         |
|                | 未提交读                                               |            | 已提交读                                             |                     | 可重复读                           |         | 可串行化                                             |
| 并发控制粒度   | 粒度最粗，见到每一个物理元组都返回给上层，认为元组可见 |            | 除了没有提交的元组不返回给上层之外，其他都返回给上层 |                     | 使得本事务不受其他事物的写操作影响 |         | 粒度最细，根据事务发生的先后顺序严格判断元组的可见性 |

 

 

我们在之前的内容中介绍了 隔离性的简单定义 **隔离性 是 隔离级别 中 最高 的级别**

现在给出更详细的 SQL 标准中对于 隔离级别 的定义

-   **`Serializable` 串行化 / 可串行化**

    -   以物理上是可串行化的机制保证逻辑上符合串行化调度

    -   一个事务在执行过程中完全看不到其他事务对数据库所做的更新

        -   事务执行的时候逻辑上不允许别的事物并发执行

        -   只能通过并发控制技术在避免事务冲突的情况下
            物理上允许多个事务是“可串行化”地执行

-   **`Repeatable Read` 可重复读**

    -   一个事务在执行的过程中可以看到其他事务已经提交的新插入的元组
        但是不能看到其他事务对已有元组的更新

    -   并且 这个是无不要求与其他事务是“可串行化”的

-   **`Read Committed` 已提交读**

    -   一个事务在执行的过程中可以看到已经提交的其他事务新插入的元组
        而且能看到已经提交的其他事务对已有元组的更新

-   **`Read Uncommitted` 未提交读**

    -   一个事务在执行过程中可以看到没有提交的其他事务新插入的元组，而且能看到没有提交的其他事务对已有元组的更新

**各种隔离级别在基于所得并发控制下的实现情况**

| 隔离级别                  | 实现方式                                                  | 不能解决的问题                      |
|---------------------------|-----------------------------------------------------------|-------------------------------------|
| `SERIALIZABLE` 可串行化     | 添加范围锁（表锁/页锁）直到事务结束                       | 幻读/不可重复读/脏读都不会发生      |
| `REPEATABLE READ` 可重复读  | 对于读出的记录 添加共享锁直到事务 T1 结束                 | 当执行一个范围查询时 可能会发生幻读 |
| `READ COMMITTED` 已提交读   | 在事务 T1 中读取数据时会对数据添加共享锁 读取结束立刻释放 | 不可重复读                          |
| `READ UNCOMMITTED` 未提交读 | 不添加共享锁                                              | 脏读                                |

-   在记录锁上添加间隙锁 直到事务结束

-   用读锁阻塞其他操作 直到事务结束

-   总之 阻止 T2 事务对 T1 事务使用的范围内的数据进行操作

-   其他事务 T2 对这个记录的修改会一直等待直到 T1 结束

-   但 允许其他事务读取同样的数据

-   其他事务 T2 对这个记录的修改会一直等待直到 T1的读取过程结束

-   不需要等待 T1 完全执行完毕

-   So 在 事务 T1 的不同阶段对同一记录的读取结果可能是不同的

-   T1 在读数据的过程中 T2 可以对数据发生改变

-   导致 T1 读取的数据是一个被破坏/不完整不正确的数据

-   在 T1 中可以读取到 T2 （未提交）修改的数据

 

**隔离技术**

常用的隔离技术 ——快照隔离

-   快照隔离 `Snapshot Isolation — SI`

    -   使用了快照隔离技术的事务中所有操作 读到的数据一定是一致的
        避免各种读异常现象

    -   不会发生 读—写 / 写—读冲突 并发效率提高

    -   从事务开始时 处于当时的并发事务的状态被保存成快照

        -   多个事务的状态 称为快照 snapshot

        -   可依据这个快照判断本事务和其他事物之间启动的先后顺序/事务的读写数据情况
            以确定是否存在 写—写冲突

-   快照隔离的技术实现手段

    -   快照隔离是 MVCC 技术的一种实现方式

    -   MVCC技术是

        -   为每个写操作发生时 生成一个新的版本

        -   为每个读操作发生时 读出最近的一个版本

    -   同一个元组因有多个版本 并发的事务有生命周期
        所以每个事务读到的元组（某个版本）是不一样的

        -   相当于并发事务在操作不同的元组对象 因此 “不存在并发”

            -   但 写—写冲突一定要操作同一个对象

    -   存在多个版本的元组级的对象 物理组织存在如下种类：

        -   磁盘类型的数据库 MVCC 冗余磁盘页内部的元组

        -   内存类型的数据库 MVCC 冗余内存中的元组

            -   前者将元组防止在页面内部 典型实现如 `PostgreSQL` / `InnoDB`

            -   后者在内存中维护一个链表 典型实现如 阿里的 `OceanBase` / 微软的 `Hekaton`

-   弊端及解决方式

    -   不能保证并发事务是可串行化的——无法保证数据一致性 ——写偏序（Write
        skew）发生

    -   解决

        -   写偏序实际是因多个版本的存在使得用户定义在数据项上的语义不能得到保证

            -   在每个版本上判断语义 相当于在不同的逻辑时空内同时操作不同的分身
                而 不能保证语义施加在同一个物理真身上

        -   `Serializable snapshot isolation` 技术

        -   `write-snapshot isolation` 技术
