---
layout:     post
title:      java 中的适配器模式（三）
subtitle:   缺省适配器模式
date:       2018-11-17
author:     Alessio
header-img: img/PostBack_03.jpg
catalog: true
tags:
    - java
    - 设计模式
---

## 缺省适配器模式介绍

我们在之前的文章中介绍了 **单适配器模式** 和 **多适配器模式** ，还有另外一种使用特别广泛的适配器模式 —— **缺省适配器模式**

简单来说，缺省适配器模式是适配器模式的简化形式，它省略了适配器模式中的目标接口，使原接口和目标接口相同，原接口为接口，目标接口为类

下图是缺省适配器结构图

 ![缺省适配器结构图](https://raw.githubusercontent.com/Zjianru/zjianru.github.io/master/img/%E7%BC%BA%E7%9C%81%E9%80%82%E9%85%8D%E5%99%A8.png)

## 缺省适配器典型例子

最典型的使用缺省适配器模式的例子，是 JavaEE 规范中的 `Servlet` 接口和 `GeneriServlet` 抽象类。

`Servlet` 接口中包含五个抽象方法，但是只有 `Service()` 方法才是为了实现业务逻辑必须实现的方法，另外四个方法一般都是空实现或者简单实现。

`GenericServlet` 抽象类实现了 `Servlet` 接口的 `Service()`  方法意外的另外四个方法，所以我们需要自定义 Servlet 的时候，只需要继承 `GrnericServlet` 抽象类，实现 `Service()` 方法即可。

反映到缺省适配器设计模式中，假设我们有一个接口，接口中有纷繁复杂的抽象方法，

但是我们需要的业务逻辑只需要用到其中的一个或几个方法，如果为了每个逻辑特地将所有方法都完成实现，将会由大量的空实现和冗余代码

我们可以在父接口之下，完成一个抽象类，在抽象类内将所有方法完成空实现或者简单实现，之后所有的业务逻辑，都来继承这个抽象类，选择自己适用的方法完成逻辑的开发
