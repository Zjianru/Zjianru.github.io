---
layout:     post
title:      事务管理与并发控制
subtitle:   并发控制基础
date:       2019-03-11
author:     Alessio
header-img: img/PostBack_03.jpg
catalog: true
tags:
    - SQL 事务
---
## **并发控制技术的实现策略**

从实现思路来看，有两类，即 **乐观与悲观并发控制 这两个的差别在于
是事后检查还是提前预防**

如果可能违反 即阻塞这样的操作

如：两端封锁技术 / 基于时间戳排序的并发控制技术

-   **乐观 `Optimistic concurrency control` —— OCC**

从一开始，每一项操作都允许进行，但事务提交的时刻，进行隔离性和完整性约束的检查
如果有违反，事务被终止
乐观并发控制方法适合并发冲突少的场景

-   **悲观 `Pessimistic concurrency control` —— PCC**

从一开始即检查每一项操作是否会违反隔离性和完整性约束   

## **并发控制技术**

并发控制技术的本质，就是要**对并发的事务实现满足下列要求的调度**

-   **正确的**

    -   保证数据的一致性 包整事务操作的原子性

-   **高效的**

    -   用 可串行性/可恢复性/严格性实现可并发

    -   部分情况下牺牲一致性

    -   或用低级别的隔离性容忍不一致以提高并发执行效率

并发控制技术，就是对并发操作进行“控制”的技术控制的含义就是进行限制，即
**限制并发以保证数据的一致性**

**串行化**的含义是完全限制并发

**可串行化**是在能保证一致性的情况下。允许某些并发的操作被执行，以提高数据整体的运行效率

 

## **并发控制技术的实现技术**

并发控制技术 从实现的技术角度来看 其主要技术包括：

| 基于时间             | `Time-stamp ordering`         |
|----------------------|-----------------------------|
| 基于提交顺序         | `Commitment ordering`         |
| 基于串行化图测试验证 | `Serialization graph testing` |
| 基于锁               | `Locking`                     |

 

-   **时间戳 `Time-stamp ordering` —— TO**

    -   基于时间戳对事务提交顺序排序的并发控制技术

    -   时间戳排序技术中存在两类主体

        -   事务

        -   数据

>   时间戳要“赋值”在这两类主体上

-   为每个事务分配一个时间值作为此事务发生的标志

    -   这个时间值就被称为 时间戳

    -   时间值取值有两种方法

        -   系统时钟

        -   逻辑计数器

-   数据项上有两个时间戳

    -   读时间戳：

>   记录读取该数据项的最大事务的时间戳

-   写时间戳

>   记录最新修改该数据项的事务的时间戳

-   因   **存在并发**  所以通过检查 Ti 事务的时间戳 和 Tj 事务数据项上的时间戳来确定并发事务 Ti 和 Tj 的先后关系

-   确保任何有冲突的 READ /WRITE 操作按照时间戳进行

时间戳并发控制技术用来保证

**在访问冲突的情况下 多个事务按照 时间戳的顺序 来访问数据项**

-   **`Commitment ordering Commit ordering` —— CO**

>   **提交排序是对提交操作的顺序进行排序 这种方式是“冲突可串行化”的一个特例**

-   区别于封锁并发控制技术在于 在事务结束之前，读或写等操作互相不阻塞
    只在提交阶段判断冲突行为——乐观

-   缺点在于 这个并发控制方法不具有可恢复性

-   被主要用于分布式事务处理 存在多种变种分布式 CO
    的特殊之处在于决定是否可提交的事件是由 `a local commitment mechanism` 或`an atomic commitment protocol` 来确定的

| a local commitment mechanism  | CO 被用于协调本地事务或者分布式事务   |
|-------------------------------|---------------------------------------|
| an atomic commitment protocol | CO 被用于在分布式环境下实现分布式事务 |

-   **串行化图形检测 `Serialization graph testing`**

>   也称:

| 优先图检测   | Precedence graph      |
|--------------|-----------------------|
| 冲突图检测   | conflict graph        |
| 串行化图检测 | serializability graph |

>   主要含义如下：

-   在一个调度 S 中每一个提交的事物都是一个节点

-   如果事务 Ti 优先且冲突于事务 Tj 则存在一条边从 Ti 节点指向 Tj 节点

-   这样 调度 S 中所有的事务代表的节点和事务之间的优先关系构成的边
    就构成了一个**有向图**

-   **串行化图形检测 就是检查上述的图中是否存在 环**

    -   **如果存在 环 则违反“冲突可串行化” 即 存在“冲突行为” 调度不应成立**

-   有向边的建立 存在三种情况 都是对于同一个数据项进行操作

    -   **Ti -R(X) —\> Tj-W(X)**

    -   **Ti-W(X)—\> Tj-R (X)**

    -   **Ti-W(X)—\> Tj-W(X)**

-   读—读操作不存在有向边

-   **两阶段封锁 Two-phase locking —— 2PL**

    -   首先 两阶段封锁强调的是两项操作 且每项操作各自为一个阶段

        -   加锁 —— 增长阶段 `growing phase`

        -   解锁 —— 缩减阶段 `shrinking phase`

>   即

-   不管同一个事务要在多少个数据项上加锁，所有的加锁操作只能在同一个阶段完成

-   在这个阶段内 不允许对已经加锁的数据项进行解锁操作 ——
    加锁和解锁操作不能在同一事务内交叉进行

-   提高并发度，对锁进行分类 分出

    -   共享锁（读锁）

    -   排他锁（写锁）

>   又产生四种 事务因并发受影响的情况

-   **两个事务并发读同一个数据项 对数据加共享锁** 不阻塞其他事务也读取本数据 ——
    “读—读”并发是允许的

-   **一读一写并发同一个数据项 对数据加共享锁** 阻塞其他数据写本数据 ——
    “读—写”并发是不允许的

>   **这里说的第一个读在前 是因 第二个读或者写是在其他事务上可能发生的操作
>   是果**

-   对数据施加排他锁 使得其他事务在这个数据项上的**读操作**被禁止

-   对数据施加排他锁 使得其他事务在这个数据项上的**写操作**被禁止

>   **这里 是针对多个事务来说的**

-   多个事务之间比较锁是否兼容 用到了锁的兼容性列表 即上面的四种情况

-   当锁的种类被扩展 增加了 意向锁 等类型 才使得锁的兼容性列表扩展

-   共享锁允许向排他锁升级 称作 **锁转换 `Lock conversion`**

    -   **升级 upgrade**

    -   **降级 downgrade**

    -   升级只能发生在增长阶段 降级只能发生在缩减阶段

    -   升降级发生在同一个事务内部 是为了提高多个事务之间的并发度

    -   同一个事物内部比较锁是否兼容 用的是锁的升级列表

-   两阶段的含义是

    -   在同一个事务内 对所涉及到的所有数据项进行先加锁 然后才对所有数据项解锁

    -   但是 两阶段封锁第一阶段

        -   加 共享锁 后影响了其他事务的 写 操作

        -   加 排他锁 后影响了其他事务的 读/写 操作

>   只有在第二阶段释放了所有的锁之后 才能运行其他要操作相同数据项的事务

-   按提交时机不同 两阶段锁可以分为

    -   S2PL

    -   SS2PL  
         

-   **多版本并发控制技术 `Multiversion concurrency control —MCC/MVCC`**

    -   事务管理器为写操作生成一个数据项的新版本

    -   当读操作发生时 按照读操作所在事务开始阶段获得的活动事务的快照
        找出应读取的某个数据项的某个版本

        -   这样 读—写操作/写—读操作 不会互相阻塞

        -   只有写写操作相互阻塞

    -   为了进一步提高并发的效率 多种并发控制技术协同使用效果更好

        -   封锁协议+MVCC

            -   前者只有 读—读 不被阻塞

            -   后者只有 写—写 阻塞

            -   组合后 使得基于封锁协议的读—写/写—读不被阻塞

    -   这里描述的只有早期的MVCC 技术 目前在 PostgreSQL 和 InnoDB 中被广泛使用

        -   其关键点在于解决 写—写操作 并发冲突

        -   但是不能避免 写偏序 数据异常

    -   新的 MVCC 技术 `write-snapshot isolation` 致力于解决 读—写冲突 并能做到
        可串行化 被分布式数据库 `CockrocachDB` 采用

-   **基于索引的并发控制技术 `Index concurrency control`**

    -   在索引树上对索引页采取封锁手段，以维护索引树的一致性

    -   可以确保避免幻读异常

        -   MySQL 的 `InnoDB` 存储引擎以 B+树作为存储的基础结构（索引组织表）

        -   可以在索引树上直接施加 `next-key locking` 进行范围锁定，以避免在谓词限定的 **谓词空间** 内 存在数据改动

 
