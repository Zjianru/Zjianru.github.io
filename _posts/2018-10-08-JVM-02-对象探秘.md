---
layout:     post
title:      JVM 之JVM 之对象探秘
subtitle:   深入理解java虚拟机 
date:       2018-10-08
author:     Alessio
header-img: img/PostBack_02.jpg
catalog: true
tags:
    - JVM
    - java
---
在我们使用 Java 语言进行代码编辑的时候，对象的创建使我们最常进行的操作。我们需要抽象出各种 pojo ，并在合适的时候使用他们的实例， 来完善我们头脑中宏大的代码帝国

如下的代码是我们最常使用的创建对象的方式之一。这行代码执行完毕，我们就拥有了一个名为 `object` 的 `Object` 类的实例。

```java
Object object = new Object();
```

现在让我们来深入到这行代码的背后。去了解代码片段之间都完成了什么样的合作，创建出了我们代码帝国的基石 —— 称其为一等公民要更好一点

## 从对象的创建开始谈起

我们来从右往左依次解释上述代码：

### 调用构造方法
`Object()` 调用了 `Object` 类中的无参构造方法，这常常是我们创建对象的第一步，在这一步中，涉及到了 JVM 加载类信息的知识点，我们会在后面的内容中更新

### new 关键字
`new` 关键字则是创建并赋予对象真正活力的关键：

>- 首先将去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号所引用的类是否已被加载、解析和初始化过 —— 如果没有，那就要先去执行相应的加载过程
>
>- 类加载检查通过之后，JVM 在接下来将会为新产生的对象分配内存，将一块确定大小的内存从 java 堆中划分出来 —— 对象的内存大小在类加载后即可确定 ( 如何确定将在后续内容中涉及 )
>>    
>>    - 然而这里我们遇到这样一个问题 ： **java 堆中的内存会不会影响到我们完成新对象的内存划分？**
>>    
>>>  - 如果 java 堆中的内存是绝对规整的，所有施工过的内存在一边，未使用的内存在一边，中间是一个指针作为分界点的指示器，分配地址仅是将指针向未分配区域挪动与对象大小相等的距离 —— 这种方式称为 “ 指针碰撞 (  ` Bump the Pointer ` ) ” 
>>>    
>>>  - 如果 java 堆中的内存是不规整的，虚拟机就必须维护一个列表，记录可用的内存块，分配的工作就变成了在表中找一块足够大小的空间划分给对象实例，并更新表上的纪录 —— 这种分配方式称为 “ 空闲列表 ( ` Free List ` ) ”

### 并发怎么办？

现在我们来考虑另外一个可能性，创建对象是一个非常频繁的操作，即使是修改一个指针的位置，在并发的情况下也并不是线程安全的，做这样一个设想：

我们正在给对象 A 分配内存，指针还没来得及修改，对象 B 又使用了原来的指针来做内存的分配

解决这样的问题，我们有两种方案：

1. 对分配内存空间的动作的动作进行同步处理 —— 事实上 JVM 采用 CAS 配上失败重试的方式来保证更新操作的原子性
2. 把内存分配的动作按照线程划分在不同的空间中进行

我来解释一下第二种方案：

使用第二种方案，我们需要为每个线程在 Java 堆中都预先分配一小块内存，我们把它称为**本地内存缓冲** —— ` Thread Local Allocation Buffer ( TLAB )`

在完成对象内存划分的时候，现在当前线程的 `TLAB` 中完成，只有 ` TLAB `  用完并分配新的 ` TLAB ` 时，才需要同步锁定

### 内存中的最后一步

分配好内存之后，虚拟机会将分配带的内存空间都初始化为零值 ( 不包括对象头 ) 。

接下来，虚拟机需要对对象进行必要的设置。这部分都会在对象头中涉及，后续会谈到

### 虚拟机视角转移至 java 程序视角

在完成了上述操作之后，从虚拟机视角来看，一个新的对象已经产生了，但从 java 程序的视角来看，一切才刚刚开始 —— 

- `<init>` 方法还没有执行
- 所有的属性都还未被赋值 

所以执行 ` new ` 指令后还会接着执行 ` <init> ` 方法，把对象按照程序员的意愿进行初始化 —— ` Object object = `

这部分代码完成了这些操作，他将一切都初始化为 `Object` 类中应该有的样子
## 对象在内存