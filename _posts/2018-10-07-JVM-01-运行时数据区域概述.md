---
layout:     post
title:      JVM 之运行时数据区域概述
subtitle:   深入理解java虚拟机 
date:       2018-10-07
author:     Alessio
header-img: img/PostBack_02.jpg
catalog: true
tags:
    - JVM
    - java内存区域与内存溢出异常
    - 自动内存管理机制 
    - JVM 之运行时数据区域概述
---
## 概述
java 虚拟机 JVM 在执行java程序的过程中，会把它所管理的内存划分为若干个不同的数据区域。

这些区域都有各自的用途，创建和销毁的时间。下述内容将依次进行介绍。

## 程序计数器

程序计数器  `Program Counter Register` 是一块较小的内存空间，它可以看作是当前线程所执行的字节码的 **行号指示器**

在虚拟机的概念模型内，字节码解释器工作时就是通过改变这个计数器的值，来选取下一条要执行的字节码指令

因为 JVM 的多线程机制 ( 线程轮流切换，分配处理器时间片 ) ，在任何确定的时刻，一个处理器都只会执行一条线程的指令

所以每个线程都需要在自己内部维护一个独立的程序计数器，这部分所占据的内存空间我们称为 “ 线程私有 ” 的内存

### `Tips of Program Counter Register`

如果当前线程执行的是一个 Java 方法，那么这个程序计数器记录的是正在执行的虚拟机字节码指令的地址

如果当前线程执行的是一个 Native 方法，这个计数器的值为空 ( `Undefined` ) 此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 `OutOfMemoryError` 情况的区域

## java 虚拟机栈
java 虚拟机栈 ` Java Virtual Machine Stacks ` 也是线程私有的，生命周期跟随线程。

虚拟机栈描述的是 Java 方法执行的内存模型：

**每个方法在执行的同时都会创建一个栈帧 ` Stack Frame ` ，用于存储局部变量表、操作数栈、动态链接、方法出口等信息**

每一个方法从调用到执行完成的过程，都对应着一个**栈帧**在虚拟机栈中入栈到出栈的过程

栈帧 —— 方法运行时的基础数据结构

Java 虚拟机规范在这个区域内规定了两种异常状况：

- 如果线程请求的栈深度大于虚拟机栈允许的栈深度，将抛出 `StackOverflowError` 异常
- 如果虚拟机栈允许动态扩展，但是在扩展时无法申请到足够的内存，将抛出 ` OutOfMemoryError ` 异常

### 局部变量表

局部变量表内存放了编译期可知的各种数据类型、对象引用、`returnAddress` 类型

### `Tips of Local variable table`

对象引用 ——  ` Reference ` 类型，它不同于对象本身，可能是一个**指向对象起始地址的指针**，也可能是指向一个**代表对象的句柄**或其他与此对象相关的位置

## 本地方法栈

本地方法栈 ( `Native Method Stack` ) 与虚拟机栈有极其相似的作用，他们之间的区别只不过是：
- 虚拟机栈为虚拟机执行 **Java 方法** ( 字节码 ) 服务
- 本地方法栈为虚拟机使用到的 **Native 方法**服务

同样的，本地方法栈也会抛出 `StackOverflowError` 异常和  ` OutOfMemoryError `  异常

## java 堆

对大多数应用来说，java 堆 ` Heap `是 Java 虚拟机所管理的内存中最大的一块。

java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，唯一目的就是存放 java 对象实例 —— 几乎所有的对象实例都会在这里被分配内存

java 堆也是垃圾收集器所管理的主要区域也被称为  **GC 堆** —— ` Garbage Collection Heap `

- 从内存回收的角度来看，基本上现在的垃圾收集器都采用了分代收集算法，因此可以把堆分为 **新生代 / 老年代**

- 从内存分配的角度来看，线程共享的 Java 堆可能划分出多个线程私有的分配缓冲区 ( `Thread Local Allocation Buffer —— TLAB` )


按照 Java 虚拟机规范的规定， Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像磁盘空间 —— 当前的主流虚拟机都依照 **可扩展** 的策略来实现 ( 通过 ` -Xmx `  和  ` -Xms ` 来控制 )

如果堆中没有内存完成势力的分配，并且堆也无法在扩展时，抛出 ` OutOfMemoryError ` 异常

## 方法区
方法区 ( `Method Area` ) 和 Java 堆一样，是各个线程共享的内存区域，用于存储 *已被虚拟机加载的类信息*、*常量*、*静态变量*、*即时编译器编译后的代码* 等数据

在 Java 虚拟机规范中，方法区被描述为堆的一个逻辑部分，但是有个别名叫做 **非堆** —— `Non-Heap`。并且规范中对方法区的限制非常宽松，可以选择不实现垃圾收集

针对方法区的垃圾收集工作是 **常量池的回收和对类型的卸载**

当方法区无法满足内存分配需求时，将抛出 ` OutOfMemoryError ` 异常

## 运行时常量池

运行时常量池 ( ` Runtime Constant Pool ` ) 是方法区的一部分。

Class 文件中出了类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池 ( ` Constant Pool Table ` )，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行常量池中存放

运行常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，可以在运行时将常量加入到程序中

## 直接内存

直接内存( ` Direct Memory ` )并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，但这部分内存也会被频繁使用 ( 例如在进行 I/O 操作时 ) 将会抛出 ` OutOfMemoryError ` 的异常