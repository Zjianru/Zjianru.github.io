---
layout:     post
title:      事务管理与并发控制
subtitle:   深入并发控制
date:       2019-03-22
author:     Alessio
header-img: img/PostBack_03.jpg
catalog: true
tags:
    - SQL 事务
---
 
**并发控制**

-   **基于锁的并发控制方法**

    -   多粒度封锁 解决了只使用一种锁导致并发效率低下

    -   两阶段封锁协议
        解决了引入多粒度锁之后导致事务调度机制不能保证事务间的并发调度是“可串行化”的

    -   **锁的粒度**

        -   锁被分为两种粒度，再进一步细化 即三种：

            -   读锁 共享锁

            -   写锁 排他锁

            -   意向锁

        -   我们得到 **锁的相容性矩阵表（不同事务间新锁的申请）**
        -   本表表示在同一个数据项上不同事物之间加锁的并发情况

        ![锁的相容性矩阵表](https://raw.githubusercontent.com/Zjianru/zjianru.github.io/master/img/%E9%94%81%E7%9A%84%E7%9B%B8%E5%AE%B9%E6%80%A7%E7%9F%A9%E9%98%B5%E8%A1%A8.png)


| Granted Mode   | 已经赋予的锁   |
|----------------|----------------|
| N              | 不存在锁       |
| IS             | 共享意向锁     |
| IX             | 排他意向锁     |
| S              | 共享锁         |
| SIX            | 共享排他意向锁 |
| U              | 更新锁         |
| X              | 排他锁         |
| Requested Mode | 将要申请的锁   |

-   由于有多种粒度的锁存在 多粒度封锁协议 `multiple-granularity Locking Protocol`
    被提出 可以增强并发度 减少锁的开销

-   我们还有**锁的合并图（同一个事务内锁的升级）**

![锁的合并图（同一个事务内锁的升级）](https://raw.githubusercontent.com/Zjianru/zjianru.github.io/master/img/%E9%94%81%E7%9A%84%E5%90%88%E5%B9%B6%E5%9B%BE.png)

-   **两阶段锁**

    -   两阶段封锁协议 `two-phase locking procotol — 2PL` 事务分为两个阶段

| 增长阶段 | growing phase   | 第一个阶段 | 事务可以获得锁 但不释放锁     |
|----------|-----------------|------------|-------------------------------|
| 缩减阶段 | shrinking phase | 第二个阶段 | 事务可以释放锁 但不能获得新锁 |

-   可以保证可串行性 但不满足可恢复性，因此不能避免级联回滚；

-   更不满足严格性 所以不能完全保证数据一致性

-   严格两阶段封锁协议 `strict two-phase locking procotol` — S2PL

    -   除了封锁满足两阶段封锁之外 还要求持有的 排他锁
        必须在事务提交之后才能释放

        -   这个要求保证未提交事务所写的任何数据在该事务在该事务提交之前均以排他方式加锁
            —— 避免级联回滚

-   强两阶段封锁协议 `rigorous/strong two-phase locking protocol — SS2PL`

    -   除了封锁满足两阶段提交之外 还要求事务提交之前不得释放任何锁

        -   这就满足了严格性

            -   严格性：先发生写操作的事务提交或中止的操作优于其他事务

-   **封锁技术是怎么解决各种读异常的**

    -   对于脏读和不可重复读 封锁技术不会发生这两种读异常现象 原因如下

    ![封锁解决读异常](https://raw.githubusercontent.com/Zjianru/zjianru.github.io/master/img/%E5%B0%81%E9%94%81%E8%A7%A3%E5%86%B3%E8%AF%BB%E5%BC%82%E5%B8%B8.png)

    -   对于幻读 我们需要分情况讨论：

        -   没有索引 使用表或页面级锁

            -   因为锁的粒度大 锁把一些不相关的元组也囊括在锁定的范围内
                这使得其他事务的 WHERE 条件不能获取锁住的表或页面

            -   相当于锁住了 WHERE 条件指定的数据对象和对象的外延范围

                -   这个外延范围被成为 间隙 “gap”

            -   幻读异常被规避

        -   没有索引 锁的粒度是元组级——操作多少元组 锁住 多少对象

            -   所以其他事务的 WHERE 条件能够不受已经加锁的影响 —— 幻读产生

            -   解决方式：升级锁的粒度到表级或页级

        -   有索引

            -   在索引上添加“谓词锁”来规避幻读

            -   枷锁不在一个对象上 即不再页面或者元组上加锁 而是在条件上加锁
                逐渐构成一个“条件”锁表来判断新的谓词锁是否可以获得

                -   如 InnoDB 中使用 Key-range locking
                    在索引上锁定一个范围而不是一个条件

                    -   在这个范围内的数据项会拒绝删除操作
                        也可以拒绝插入和更新操作

            -   幻读被规避

        -   谓词锁 —— `perdicate lock`

            -   是一个具有普遍意义的“谓词锁”的概念 专用于避免幻读现象的技术

            -   幻读产生是因为 WHRER 子句中的 谓词条件 触发 因此取名 谓词锁

-   **死锁相关**

    -   进程在利用可重用性资源时产生死锁的四个必要条件：

        -   互斥使用 —— `Mutual exclusion`

            -   资源不能被共享 只能由一个进程在同一时刻使用

        -   持有和等待 —— `Resource holding and waiting`

            -   进程已持有部分资源并等待得到另外的资源
                而这些资源又被其他进程占用所占用还未释放

        -   非抢占分配 —— `nonpreemption`

            -   已经分配的资源不能从相应的进程中被强行剥夺

        -   部分分配 或 循环等待—— `partial allocation / circular waiting`

            -   至少存在包含两个进程的下一个循环链
                链中的一个进程等待被链中另一个进程占有的资源

            -   即 **在一定条件下 若干进程进入了相互无休止地等待所需资源的状态**

    -   死锁的处理方法：

        -   死锁预防 `deadlock prevention`

            - 一次封锁法
            
            事务在运行时将要用到的数据一次性全部加锁 —— "你们都得等我"

            - 顺序封锁法

            预先规定一个数据对象的封锁顺序，所有事务按照这个顺序加锁

        -   死锁检测 `deadlock detection` + 死锁恢复 `deadlock recovery`

            超时法 或 事务等待图法

        -   死锁避免 `deadlock avoidence`
        -   通常做法是选择一个处理死锁代价最小（看看谁死了最不影响大局）的事务，把它 kill 掉，释放这个事务持有的锁，让其他的事务继续运行，之后对 kill 掉的事务进行恢复（人家也不是白死，当然得管管后事儿）

-   **锁的并发度问题**

    -   细粒度的锁会使并发度提高——注意锁的粒度

    -   锁的封锁范围也影响封锁协议的并发度

        -   数据库的调度机制
            如果使用了基于锁的并发控制方法，就是要在保证可串行化的情况下
            尽量减少所对并发事务的影响 提高并发度 ——并发事务的执行效率

-   **基于时间戳的并发控制方法**

    -   基于时间戳的并发控制技术
        是根据事务开始的时间戳和其他事务地读写操作的时间戳作比较来决定发生冲突时事务该如何处理

    -   **基于时间戳的并发调度算法**

    ![基于时间戳的并发调度算法](https://raw.githubusercontent.com/Zjianru/zjianru.github.io/master/img/%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png)

    -   **Thomas 写法则**

        -   Thomas 写法则是基于时间戳的并发控制技术的一项改进措施

        -   有助于改进基于时间戳的并发控制效率
            使特定情况的写操作被“节省”而提高了执行效率

        -   但 几乎没有单纯使用基于时间戳排序的并发控制方法

    -   **基于有效性检查的并发控制方法**

        ![基于有效性检查的并发控制方法](https://raw.githubusercontent.com/Zjianru/zjianru.github.io/master/img/%E5%9F%BA%E4%BA%8E%E6%9C%89%E6%95%88%E6%80%A7%E6%A3%80%E6%9F%A5%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95.png)

        -   基于有效性检查的并发控制技术（validation protocol），对于每一个事务
            在其生命周期中被划分成两个或三个阶段 每个事务必须按照如下次序进行：

            -   读阶段 `read phase`

                -   对于事务 T1 涉及的数据项被读入到事务 T1 的局部变量中
                    因此写操作都是对局部变量进行修改
                    并不对数据库中的数据项进行真正更新

                    -   没有读—写 写—读 写—写 冲突 即不需要延迟冲突操作

                        -   在读写阶段事务的并发度会很高

                        -   同时 事务也在“乐观”地执行
                            只在读和写操作完成之后才被判断是否存在

            -   有效性检查（`validation phase`）阶段

                -   根据有效性检查规则 对事务 T1 进行有效性测试——事务 T1 的
                    write 操作是否违反可串行性

                    -   违反则中止

            -   写阶段 write phase

                -   如果事务的有效性检查通过 则被事务 T1
                    的被写过的局部变量的值复制到数据库中

                    -   只读事务不需要本阶段操作

        -   有效性检查规则 是指:

            -   标记事务 T1 的各个阶段是在何时进行的

            -   利用时间戳的值 通过时间戳排序控制技术决定可串行性

-   **基于 MVCC 的并发控制方法**

    -   MVCC 技术的核心思想是：

        -   事务 T1 执行一个**读操作** 并发控制器选择一个**版本**读
            这个版本的获取 依赖于事务当前读取数据的**快照**
            快照中的信息能够帮助判断 **获取到的元组是否对本事务是可读的**

        -   多版本并发控制技术**不是一个可独立使用**的事务并发技术

            -   基于时间戳的叫 **多版本时间戳排序机制 `multiversion timestamp-ordering scheme`**

            -   基于两段封锁协议的叫 **多版本两段封锁协议 `multiversion two-phase locking protocol`**

        -   **两种控制技术的比较**

        ![两种控制技术的比较](https://raw.githubusercontent.com/Zjianru/zjianru.github.io/master/img/%E4%B8%A4%E7%A7%8D%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF%E7%9A%84%E6%AF%94%E8%BE%83.png)

-   **基于 MVCC 的可串行化快照隔离并发控制方法**

    -   `Serializable Snapshot Isolation` 可串行化的快照隔离 简称 SSI

    -   基于 MVCC 的多版本 也基于快照隔离的思想

    -   SSI 整体流程与 SI 相同 只是增加了一些 `book-keeping` 记录下事务的一些信息以便动态地检测是否有写偏序发生 如果有则回滚该事务
