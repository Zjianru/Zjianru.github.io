---
layout:     post
title:      java 集合框架（三）
subtitle:   Set 接口
date:       2018-11-08
author:     Alessio
header-img: img/PostBack_03.jpg
catalog: true
tags:
    - java
    - 集合框架
---
## Set 接口

在之前的内容中，我们简单叙述了 `Collection` 接口内的多个接口方法，并给出了官方的继承关系图，那么这次我们就顺藤摸瓜，来说一说 Set

在下面的图示中，我们可以清楚地看到 Set 家族的继承关系

![Set 家族继承关系](https://raw.githubusercontent.com/Zjianru/zjianru.github.io/master/img/Collection%E5%AE%B6%E6%97%8F%E5%9B%BE%E8%B0%B1.png)

在官方文档的描述中， Set 被定义成一个不能包含重复元素的 Collection，模拟了数学集抽象

在 Set 接口中，方法大致与 Collection 接口无区别。只是添加了禁止元素重复的限制方法，并重写了 ` equals() ` 和 `hashCode() ` 方法，使得两个Set 之间的比较不再是比较内存地址，而是比较集合内的内容

### 继承关系解释

在实现上，java 提供了三种实现方案

- `HashSet`

> `HashSet` 使用 哈希表(`HashTable`) 来存储数据，能够提供比较好的性能，但是不能保证迭代的顺序 

- `LinkedHashSet`

> `LinkedHashSet` 实现为哈希表，通过链表的形式进行数据的存储，数据的存储位置取决于他们的插入顺序，虽然付出了一点空间成本，但是保证了元素在其内部是有序的

- `TreeSet`

> `TreeSet` 使用红黑树来存储数据，基于元素的内容（值）来对元素进行排序，但是速度相较于 `HashSet` 会慢很多

### 接口操作浅析

刚才我们提到，Set 接口继承了 Collection 接口，在接口的功能方面做了一些声明，将具体的操作交给了继承关系中下层的具体结构来完成实现

在 Set 接口中，存在这样几个基础不同的的操作：

```java
// 将返回 Set 中的元素数量
int size();
// 如果 Set 中还有值，将返回 True
boolean isEmpty();
```

现在我们将完成一个简单的举例，这个例子有种写法，分别是 Stream 版本和 for-each 版本

```java
//Stream 版本
public static void main(String[] args) {
    Set<String> distinctWords = new HashSet<>(Arrays.asList(args));
    System.out.println(distinctWords.size()+
            " distinct words: " +
            distinctWords);
}
// for-each 版本
public static void main(String[] args) {
    Set<String> s = new HashSet<>();
    Collections.addAll(s, args);
    System.out.println(s.size() + " distinct words: " + s);
}
```